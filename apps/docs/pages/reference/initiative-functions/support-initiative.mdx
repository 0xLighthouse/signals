---
title: 'supportInitiative Function'
weight: 2
---

# Supporting Initiatives

## Function Signature

```solidity
function supportInitiative(
    uint256 initiativeId,
    uint256 amount,
    uint256 lockDuration
) external returns (uint256 tokenId)
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `initiativeId` | `uint256` | ID of the initiative to support (must exist and be in Proposed state) |
| `amount` | `uint256` | Amount of tokens to lock (in wei, e.g., `100000 * 1e18`) |
| `lockDuration` | `uint256` | Duration to lock tokens, **measured in intervals** (must be > 0 and ≤ `maxLockIntervals`) |

### Returns

- `tokenId` - An ERC721 NFT token ID representing your lock position

### Example

```solidity
// Support initiative #5 with 100k tokens for 30 days
// Assumes lockInterval = 1 day
uint256 tokenId = signals.supportInitiative(
    5,                  // initiativeId
    100_000 * 1e18,    // 100k tokens
    30                  // 30 intervals (30 days)
)
```

## Token Approval

```solidity
// 1. Approve tokens
IERC20(underlyingToken).approve(signalsContractAddress, amount)

// 2. Support initiative
signals.supportInitiative(initiativeId, amount, lockDuration)
```

## Participant Requirements

```solidity
struct ParticipantRequirements {
    EligibilityType eligibilityType;
    uint256 minBalance;
    uint256 minHoldingDuration;
}
```

### None Type Example

```solidity
ParticipantRequirements({
    eligibilityType: EligibilityType.None,
    minBalance: 0,
    minHoldingDuration: 0
})
```

### MinBalance Type Example

```solidity
ParticipantRequirements({
    eligibilityType: EligibilityType.MinBalance,
    minBalance: 75_000 * 1e18,
    minHoldingDuration: 0
})
```

### MinBalanceAndDuration Type Example

```solidity
ParticipantRequirements({
    eligibilityType: EligibilityType.MinBalanceAndDuration,
    minBalance: 40_000 * 1e18,
    minHoldingDuration: 50400  // blocks (~7 days at 12s/block)
})
```

## Weight Calculation

### Initial Weight Formula

```solidity
initialWeight = amount * lockDuration
```

**Example:**
- Lock 100 tokens for 10 intervals
- Initial weight = 100 × 10 = **1,000**

### Weight Decay

#### Linear Decay (Type 0)

```solidity
weight = lockAmount * lockDuration - (lockAmount * elapsedIntervals * decayRate)
// Floored at lockAmount minimum
```

**Example with decayRate = 1e18:**
- Interval 0: 100 × 10 = 1,000
- Interval 5: 1,000 - (100 × 5) = 500
- Interval 10: Weight = 0 (expired)

#### Exponential Decay (Type 1)

```solidity
weight = initialWeight * (decayMultiplier ^ elapsedIntervals)
// Floored at lockAmount minimum
```

**Example with multiplier = 0.9:**
- Interval 0: 1,000
- Interval 1: 1,000 × 0.9 = 900
- Interval 2: 900 × 0.9 = 810
- Interval 3: 810 × 0.9 = 729

### Weight Floor

Weight never drops below the lock amount (nominal value) until the lock expires.

## Lock Data Structures

### TokenLock

```solidity
struct TokenLock {
    uint256 initiativeId;     // Which initiative this supports
    uint256 tokenAmount;      // Underlying tokens locked
    uint256 lockDuration;     // Duration in intervals
    uint256 created;          // Block timestamp of creation
    bool withdrawn;           // Redemption status
}
```

### LockData (ISignalsLock interface)

```solidity
struct LockData {
    uint256 referenceId;      // Initiative ID
    uint256 nominalValue;     // Token amount
    uint256 expires;          // Expiry timestamp
    uint256 created;
    bool claimed;
}
```

### Query Lock Data

```solidity
// Get detailed lock information
TokenLock memory lock = signals.getTokenLock(tokenId)

// Get standardized lock data (ISignalsLock interface)
LockData memory data = signals.getLockData(tokenId)
```

## Events Emitted

```solidity
event InitiativeSupported(
    uint256 indexed initiativeId,
    address indexed supporter,
    uint256 tokenAmount,
    uint256 lockDuration,
    uint256 tokenId
)
```

**Event Data:**
- `initiativeId`: Which initiative was supported
- `supporter`: Your address (NFT recipient)
- `tokenAmount`: Amount of tokens locked
- `lockDuration`: Lock duration in intervals
- `tokenId`: ERC721 token ID minted

## State Updates

When you support an initiative:

```solidity
// Initiative updates
initiative.underlyingLocked += amount        // Track total locked
initiative.lastActivity = block.timestamp    // Reset inactivity timer

// Supporter tracking
supporters[initiativeId].push(supporter)     // Add to supporters list
isSupporter[initiativeId][supporter] = true  // Mark as supporter

// Lock tracking
initiativeLocks[initiativeId].push(tokenId)  // Track locks per initiative
supporterLocks[supporter].push(tokenId)      // Track locks per supporter
```

## Validation & Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `Signals_BoardNotYetOpen` | Current time < `boardOpensAt` | Wait for board to open |
| `Signals_BoardClosed` | Board is closed | Cannot support on closed boards |
| `Signals_InitiativeNotFound` | Invalid initiative ID | Use valid initiative ID |
| `Signals_NotProposedState` | Initiative not in Proposed state | Only support Proposed initiatives |
| `Signals_InvalidLockDuration` | Duration = 0 or > `maxLockIntervals` | Use valid duration |
| `Signals_InsufficientTokens` | Balance < amount | Acquire more tokens |
| `Signals_TokenTransferFailed` | Transfer failed | Check approval and balance |
| `Signals_ParticipantInsufficientBalance` | Balance < `minBalance` | Acquire more tokens |
| `Signals_ParticipantInsufficientDuration` | Haven't held tokens long enough | Wait or use different account |
| `Signals_ParticipantNoCheckpointSupport` | Token doesn't support IVotes | Board misconfigured |

## Complete Example Flow

```solidity
// Setup
address supporter = 0x1111
uint256 initiativeId = 5
IERC20 token = IERC20(signals.underlyingToken())

// 1. Check eligibility
require(signals.canParticipate(supporter), 'Not eligible')

// 2. Check initiative state
Initiative memory init = signals.getInitiative(initiativeId)
require(init.state == InitiativeState.Proposed, 'Not proposed')

// 3. Approve tokens
uint256 amount = 150 * 1e18
token.approve(address(signals), amount)

// 4. Support initiative
uint256 lockDuration = 6  // 6 intervals
uint256 tokenId = signals.supportInitiative(initiativeId, amount, lockDuration)

// 5. Verify NFT received
require(signals.ownerOf(tokenId) == supporter, 'NFT not received')

// 6. Check lock details
TokenLock memory lock = signals.getTokenLock(tokenId)
assert(lock.tokenAmount == amount)
assert(lock.lockDuration == lockDuration)

// 7. Check weight contribution
uint256 myWeight = signals.getWeightForSupporterAt(
    initiativeId,
    supporter,
    block.timestamp
)
// Initial: myWeight = 150 * 6 = 900 (decays over time)

// 8. Check total initiative weight
uint256 totalWeight = signals.getWeight(initiativeId)
uint256 threshold = signals.acceptanceThreshold()
bool meetsThreshold = totalWeight >= threshold

// 9. Later: Redeem after acceptance/expiration
// ... wait for acceptance/expiration ...
signals.redeem(tokenId)  // Receive original tokens back + incentives
```

## Helper Functions

```solidity
// Check if you can participate
function canParticipate(address participant) external view returns (bool)

// Get participant requirements
function getParticipantRequirements() external view returns (ParticipantRequirements memory)

// Get all your lock positions
function getLocksForSupporter(address supporter) external view returns (uint256[] memory)

// Get lock count for supporter
function getLockCountForSupporter(address supporter) external view returns (uint256)

// List all NFT positions you own
function listPositions(address owner) external view returns (uint256[] memory)
```

## Incentive Rewards

```solidity
// Preview rewards before acceptance (if IncentivesPool configured)
uint256 rewards = incentivesPool.getSupporterRewards(
    address(signals),
    initiativeId,
    supporter
)
```
