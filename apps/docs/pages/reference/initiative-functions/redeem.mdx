---
title: 'redeemLock Functions'
weight: 3
---

# Redeeming Locks

## Function Signatures

### Redeem Single Lock

```solidity
function redeemLock(uint256 lockId) external
```

### Redeem Multiple Locks (Batch)

```solidity
function redeemLocksForInitiative(
    uint256 initiativeId,
    uint256[] calldata lockIds
) external
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `lockId` | `uint256` | The ERC721 token ID representing your lock position |
| `initiativeId` | `uint256` | The initiative ID (all locks must belong to this initiative) |
| `lockIds` | `uint256[]` | Array of lock token IDs to redeem in batch |

## TokenLock Data Structure

```solidity
struct TokenLock {
    uint256 initiativeId;     // Which initiative this supports
    uint256 tokenAmount;      // Underlying tokens locked
    uint256 lockDuration;     // Duration in intervals
    uint256 created;          // Block timestamp of creation
    bool withdrawn;           // Redemption status
}
```

## Checking Redemption Status

```solidity
// Get initiative details
Initiative memory init = signals.getInitiative(initiativeId)

// Check if redeemable
bool isRedeemable = (init.state == InitiativeState.Accepted ||
                     init.state == InitiativeState.Expired)

// For accepted initiatives, check if timelock has passed
if (init.state == InitiativeState.Accepted) {
    uint256 releaseTime = init.acceptanceTimestamp + releaseLockDuration
    bool canRedeemNow = block.timestamp >= releaseTime
}
```

## Finding Your Token IDs

```solidity
// Get all your lock positions
uint256[] memory tokenIds = signals.listPositions(yourAddress)

// Or get locks for specific supporter
uint256[] memory tokenIds = signals.getLocksForSupporter(yourAddress)
```

## Example Redemption Flow

### Single Lock Redemption

```solidity
// 1. Find your positions
uint256[] memory myTokenIds = signals.listPositions(msg.sender)

// 2. For each token, check if redeemable
for (uint256 i = 0; i < myTokenIds.length; i++) {
    uint256 lockId = myTokenIds[i]

    // Get lock details
    TokenLock memory lock = signals.getTokenLock(lockId)

    // Skip if already withdrawn
    if (lock.withdrawn) continue

    // Get initiative
    Initiative memory init = signals.getInitiative(lock.initiativeId)

    // Check if redeemable
    if (init.state == InitiativeState.Accepted) {
        uint256 releaseTime = init.acceptanceTimestamp + signals.releaseLockDuration()
        if (block.timestamp >= releaseTime) {
            // Redeem single lock
            signals.redeemLock(lockId)
        }
    } else if (init.state == InitiativeState.Expired) {
        // Redeem immediately
        signals.redeemLock(lockId)
    }
}
```

### Batch Redemption for Initiative

```solidity
// 1. Get all your locks for a specific initiative
uint256 initiativeId = 5;
uint256[] memory myLocks = signals.getLocksForSupporter(msg.sender);

// 2. Filter locks for this initiative
uint256[] memory initiativeLocks = new uint256[](myLocks.length);
uint256 count = 0;

for (uint256 i = 0; i < myLocks.length; i++) {
    TokenLock memory lock = signals.getTokenLock(myLocks[i]);
    if (lock.initiativeId == initiativeId && !lock.withdrawn) {
        initiativeLocks[count] = myLocks[i];
        count++;
    }
}

// 3. Resize array to actual count
uint256[] memory locksToRedeem = new uint256[](count);
for (uint256 i = 0; i < count; i++) {
    locksToRedeem[i] = initiativeLocks[i];
}

// 4. Batch redeem all locks for this initiative
if (locksToRedeem.length > 0) {
    signals.redeemLocksForInitiative(initiativeId, locksToRedeem);
}
```

## Validation & Errors

| Error | Condition | Solution |
|-------|-----------|----------|
| `Signals_AlreadyRedeemed` | Position already redeemed | Check `lock.withdrawn` status |
| `Signals_NotTokenOwner` | You don't own the NFT | Verify NFT ownership |
| `Signals_NotWithdrawableState` | Initiative still Proposed | Wait for acceptance or expiration |
| `Signals_StillTimelocked` | Release timelock not passed | Wait until `acceptanceTimestamp + releaseLockDuration` |

## Frontend Integration

```typescript
// Check if user can redeem
async function canRedeem(tokenId: bigint) {
  // Get lock details
  const lock = await signals.read.getTokenLock([tokenId])

  // Already withdrawn?
  if (lock.withdrawn) return false

  // Get initiative
  const initiative = await signals.read.getInitiative([lock.initiativeId])

  // Check state
  if (initiative.state === 0) return false  // 0 = Proposed

  if (initiative.state === 1) {  // 1 = Accepted
    const releaseLockDuration = await signals.read.releaseLockDuration()
    const releaseTime = initiative.acceptanceTimestamp + releaseLockDuration
    return BigInt(Date.now() / 1000) >= releaseTime
  }

  if (initiative.state === 3) {  // 3 = Expired
    return true  // Immediate redemption
  }

  return false
}

// Redeem single position
async function redeemPosition(lockId: bigint) {
  const tx = await signals.write.redeemLock([lockId])
  await tx.wait()
  console.log(`Redeemed lock ${lockId}`)
}

// Redeem multiple positions for an initiative
async function redeemMultiplePositions(
  initiativeId: bigint,
  lockIds: bigint[]
) {
  const tx = await signals.write.redeemLocksForInitiative([
    initiativeId,
    lockIds
  ])
  await tx.wait()
  console.log(`Redeemed ${lockIds.length} locks for initiative ${initiativeId}`)
}
```

## Related Functions

```solidity
// Query functions
function getTokenLock(uint256 tokenId) external view returns (TokenLock memory)
function getInitiative(uint256 initiativeId) external view returns (Initiative memory)
function listPositions(address owner) external view returns (uint256[] memory)
function releaseLockDuration() external view returns (uint256)

// Redemption
function redeemLock(uint256 lockId) external
function redeemLocksForInitiative(uint256 initiativeId, uint256[] calldata lockIds) external
```
