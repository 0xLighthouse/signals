---
title: "Reclaiming Locked Tokens"
weight: 6
---

# Reclaiming Locked Tokens

When you support an initiative by locking tokens, you receive an ERC721 NFT representing your lock position. Once the initiative is accepted or expired, you can redeem this NFT to reclaim your locked tokens (plus any rewards).

## When Can You Redeem?

Your locks become redeemable when the initiative reaches a terminal state:

### Accepted Initiatives

If the initiative is **accepted** by the board owner:
- Wait for the `releaseLockDuration` to pass (if configured)
- If `releaseLockDuration = 0`, redeem immediately
- If `releaseLockDuration > 0` (e.g., 7 days), wait until `acceptanceTimestamp + releaseLockDuration`

### Expired Initiatives

If the initiative is **expired** by the board owner:
- Redeem immediately - no waiting period

### Board Closure (Emergency)

If the **board is closed** by the owner:
- All locks become immediately redeemable regardless of initiative state
- Release timelock is bypassed

## Redemption Function

```solidity
function redeem(uint256 tokenId) public
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `tokenId` | `uint256` | The ERC721 token ID representing your lock position |

### What You Receive

When you redeem, you get:

**From Accepted Initiatives:**
- ✅ Your original locked tokens
- ✅ Incentive rewards (automatically claimed if configured)
- ✅ Bounty rewards available to claim separately

**From Expired Initiatives:**
- ✅ Your original locked tokens only
- ❌ No incentive rewards
- ❌ No bounty rewards

## How to Redeem

### Check Redemption Status

```solidity
// Get initiative details
Initiative memory init = signals.getInitiative(initiativeId)

// Check if redeemable
bool isRedeemable = (init.state == InitiativeState.Accepted ||
                     init.state == InitiativeState.Expired)

// For accepted initiatives, check if timelock has passed
if (init.state == InitiativeState.Accepted) {
    uint256 releaseTime = init.acceptanceTimestamp + releaseLockDuration
    bool canRedeemNow = block.timestamp >= releaseTime
}
```

### Redeem Your Position

```solidity
// Redeem using your NFT token ID
signals.redeem(tokenId)
```

### Find Your Token IDs

```solidity
// Get all your lock positions
uint256[] memory tokenIds = signals.listPositions(yourAddress)

// Or get locks for specific supporter
uint256[] memory tokenIds = signals.getLocksForSupporter(yourAddress)
```

## Example Redemption Flow

```solidity
// 1. Find your positions
uint256[] memory myTokenIds = signals.listPositions(msg.sender)

// 2. For each token, check if redeemable
for (uint256 i = 0; i < myTokenIds.length; i++) {
    uint256 tokenId = myTokenIds[i]

    // Get lock details
    TokenLock memory lock = signals.getTokenLock(tokenId)

    // Skip if already withdrawn
    if (lock.withdrawn) continue

    // Get initiative
    Initiative memory init = signals.getInitiative(lock.initiativeId)

    // Check if redeemable
    if (init.state == InitiativeState.Accepted) {
        uint256 releaseTime = init.acceptanceTimestamp + signals.releaseLockDuration()
        if (block.timestamp >= releaseTime) {
            // Redeem
            signals.redeem(tokenId)
        }
    } else if (init.state == InitiativeState.Expired) {
        // Redeem immediately
        signals.redeem(tokenId)
    }
}
```

## Multiple Positions on Same Initiative

If you locked tokens multiple times on the same initiative:
- Each lock has its own NFT token ID
- Redeem each position separately
- Incentive rewards (if any) are claimed on first redemption
- Subsequent redemptions just return locked tokens

## What Happens During Redemption

The `redeem()` function:

1. **Validates** the lock hasn't been redeemed
2. **Verifies** you own the NFT
3. **Checks** initiative state is Accepted or Expired
4. **Validates** release timelock has passed (for Accepted)
5. **Marks** lock as withdrawn
6. **Burns** the NFT
7. **Transfers** locked tokens back to you
8. **Auto-claims** incentive rewards (for Accepted initiatives)

## Common Errors

| Error | Condition | Solution |
|-------|-----------|----------|
| `Signals_AlreadyRedeemed` | Position already redeemed | Check `lock.withdrawn` status |
| `Signals_NotTokenOwner` | You don't own the NFT | Verify NFT ownership |
| `Signals_NotWithdrawableState` | Initiative still Proposed | Wait for acceptance or expiration |
| `Signals_StillTimelocked` | Release timelock not passed | Wait until `acceptanceTimestamp + releaseLockDuration` |

## Frontend Integration

```typescript
// Check if user can redeem
async function canRedeem(tokenId: bigint) {
  // Get lock details
  const lock = await signals.read.getTokenLock([tokenId])

  // Already withdrawn?
  if (lock.withdrawn) return false

  // Get initiative
  const initiative = await signals.read.getInitiative([lock.initiativeId])

  // Check state
  if (initiative.state === 0) return false  // 0 = Proposed

  if (initiative.state === 1) {  // 1 = Accepted
    const releaseLockDuration = await signals.read.releaseLockDuration()
    const releaseTime = initiative.acceptanceTimestamp + releaseLockDuration
    return BigInt(Date.now() / 1000) >= releaseTime
  }

  if (initiative.state === 3) {  // 3 = Expired
    return true  // Immediate redemption
  }

  return false
}

// Redeem position
async function redeemPosition(tokenId: bigint) {
  const tx = await signals.write.redeem([tokenId])
  await tx.wait()
  console.log(`Redeemed token ${tokenId}`)
}
```

## Claiming Bounty Rewards

Incentive rewards are automatically claimed during redemption, but bounty rewards must be claimed separately from the Bounties contract:

```solidity
// After redeeming your locks, claim bounty rewards
bounties.claimRewards(tokenAddress)  // Not yet implemented
```

**Note:** The bounty claiming function is defined but not yet implemented in the current version.

## Best Practices

1. **Check before redeeming** - Verify the initiative is in a redeemable state
2. **Wait for full timelock** - Don't attempt to redeem before `releaseTime`
3. **Track your positions** - Use `listPositions()` to see all your locks
4. **Monitor initiative state** - Watch for acceptance or expiration events
5. **Redeem promptly** - Claim rewards while pool still has funds (for incentives)

## Related Functions

```solidity
// Query functions
function getTokenLock(uint256 tokenId) external view returns (TokenLock memory)
function getInitiative(uint256 initiativeId) external view returns (Initiative memory)
function listPositions(address owner) external view returns (uint256[] memory)
function releaseLockDuration() external view returns (uint256)

// Redemption
function redeem(uint256 tokenId) public
```