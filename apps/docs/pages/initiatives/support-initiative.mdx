---
title: "Add Support to an Initiative"
weight: 2
---

# Add Support to an Initiative

Supporting an initiative allows community members to lock tokens to signal their backing for a proposed idea. Support is represented by an ERC721 NFT that can be redeemed once the initiative is accepted or expired.

## Overview

When you support an initiative, you:
1. Lock ERC20 tokens for a specified duration
2. Receive an ERC721 NFT representing your lock position
3. Contribute weight toward the initiative's acceptance threshold
4. Become eligible for incentive rewards (if configured)

## Function Signature

```solidity
function supportInitiative(
    uint256 initiativeId,
    uint256 amount,
    uint256 lockDuration
) external returns (uint256 tokenId)
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `initiativeId` | `uint256` | ID of the initiative to support (must exist and be in Proposed state) |
| `amount` | `uint256` | Amount of tokens to lock (in wei, e.g., `100000 * 1e18`) |
| `lockDuration` | `uint256` | Duration to lock tokens, **measured in intervals** (must be > 0 and ≤ `maxLockIntervals`) |

### Returns

- `tokenId` - An ERC721 NFT token ID representing your lock position

### Example

```solidity
// Support initiative #5 with 100k tokens for 30 days
// Assumes lockInterval = 1 day
uint256 tokenId = signals.supportInitiative(
    5,                  // initiativeId
    100_000 * 1e18,    // 100k tokens
    30                  // 30 intervals (30 days)
)
```

## Prerequisites

Before supporting an initiative, ensure:

1. **Board is open** - Current time ≥ `boardOpensAt` and board state is Open
2. **Initiative exists and is in Proposed state** - Cannot support accepted or expired initiatives
3. **You meet participant requirements** - Check eligibility with `canParticipate(address)`
4. **You have sufficient tokens and approval** - Balance ≥ amount and approved the Signals contract

## Token Approval

You must approve the Signals contract to spend your tokens before calling `supportInitiative`:

```solidity
// 1. Approve tokens
IERC20(underlyingToken).approve(signalsContractAddress, amount)

// 2. Support initiative
signals.supportInitiative(initiativeId, amount, lockDuration)
```

## Participant Eligibility

Boards configure three types of participant requirements:

### 1. None (Most Permissive)

Anyone can participate:

```solidity
ParticipantRequirements({
    eligibilityType: EligibilityType.None,
    minBalance: 0,
    minHoldingDuration: 0
})
```

**Requirements:**
- Just need tokens to lock

### 2. Minimum Balance

Participants must hold a minimum token balance:

```solidity
ParticipantRequirements({
    eligibilityType: EligibilityType.MinBalance,
    minBalance: 75_000 * 1e18,
    minHoldingDuration: 0
})
```

**Requirements:**
- Hold ≥ `minBalance` tokens at support time
- Prevents low-balance sybil attacks

### 3. Minimum Balance and Duration (Most Restrictive)

Participants must hold tokens for a minimum duration:

```solidity
ParticipantRequirements({
    eligibilityType: EligibilityType.MinBalanceAndDuration,
    minBalance: 40_000 * 1e18,
    minHoldingDuration: 50400  // blocks (~7 days at 12s/block)
})
```

**Requirements:**
- Currently hold ≥ `minBalance` tokens
- **AND** have held ≥ `minBalance` for ≥ `minHoldingDuration` blocks
- **Token must support ERC20Votes** (checkpoint functionality)

## Weight Contribution

Your support contributes weight toward the initiative's acceptance threshold. Weight is calculated based on lock amount, duration, and time decay.

### Initial Weight Formula

```solidity
initialWeight = amount * lockDuration
```

**Example:**
- Lock 100 tokens for 10 intervals
- Initial weight = 100 × 10 = **1,000**

### Weight Decay

Weight decays over time based on the board's decay curve:

#### Linear Decay (Type 0)

Weight decreases steadily:

```solidity
weight = lockAmount * lockDuration - (lockAmount * elapsedIntervals * decayRate)
// Floored at lockAmount minimum
```

**Example with decayRate = 1e18:**
- Interval 0: 100 × 10 = 1,000
- Interval 5: 1,000 - (100 × 5) = 500
- Interval 10: Weight = 0 (expired)

#### Exponential Decay (Type 1)

Weight decreases at an accelerating rate:

```solidity
weight = initialWeight * (decayMultiplier ^ elapsedIntervals)
// Floored at lockAmount minimum
```

**Example with multiplier = 0.9:**
- Interval 0: 1,000
- Interval 1: 1,000 × 0.9 = 900
- Interval 2: 900 × 0.9 = 810
- Interval 3: 810 × 0.9 = 729

### Weight Floor

Weight never drops below the lock amount (nominal value) until the lock expires.

## NFT Lock Position

When you support an initiative, you receive an ERC721 NFT representing your lock position.

### NFT Properties

- **Name:** `{underlyingToken.name()} Locked Support`
  - Example: "StandardToken Locked Support"
- **Symbol:** `sx{underlyingToken.symbol()}`
  - Example: "sxSTD"
- **Transferable:** Yes - you can trade your lock position
- **Redeemable:** Holder can redeem underlying tokens after acceptance/expiration

### Lock Data Structure

```solidity
struct TokenLock {
    uint256 initiativeId;     // Which initiative this supports
    uint256 tokenAmount;      // Underlying tokens locked
    uint256 lockDuration;     // Duration in intervals
    uint256 created;          // Block timestamp of creation
    bool withdrawn;           // Redemption status
}
```

### Query Lock Data

```solidity
// Get detailed lock information
TokenLock memory lock = signals.getTokenLock(tokenId)

// Get standardized lock data (ISignalsLock interface)
LockData memory data = signals.getLockData(tokenId)
```

## Multiple Lock Positions

You can support the same initiative multiple times:

```solidity
// First support
uint256 tokenId1 = signals.supportInitiative(1, 100 * 1e18, 5)  // 5 intervals

// Second support (same initiative, different amount/duration)
uint256 tokenId2 = signals.supportInitiative(1, 200 * 1e18, 10) // 10 intervals
```

Each support creates a **separate NFT** with independent:
- Lock duration
- Amount
- Creation timestamp
- Decay calculation

## Events Emitted

```solidity
event InitiativeSupported(
    uint256 indexed initiativeId,
    address indexed supporter,
    uint256 tokenAmount,
    uint256 lockDuration,
    uint256 tokenId
)
```

**Event Data:**
- `initiativeId`: Which initiative was supported
- `supporter`: Your address (NFT recipient)
- `tokenAmount`: Amount of tokens locked
- `lockDuration`: Lock duration in intervals
- `tokenId`: ERC721 token ID minted

## Validation & Requirements

### Pre-conditions

1. ✅ **Board is open**
   - `boardState == Open`
   - `block.timestamp >= boardOpensAt`

2. ✅ **Initiative exists and is Proposed**
   - `initiativeId <= initiativeCount`
   - `initiative.state == Proposed`

3. ✅ **Valid lock duration**
   - `0 < lockDuration <= maxLockIntervals`

4. ✅ **Sufficient tokens**
   - Your balance ≥ amount
   - Signals contract approved for ≥ amount

5. ✅ **Participant requirements met**
   - Based on board configuration (see Eligibility section)

### State Updates

When you support an initiative:

```solidity
// Initiative updates
initiative.underlyingLocked += amount        // Track total locked
initiative.lastActivity = block.timestamp    // Reset inactivity timer

// Supporter tracking
supporters[initiativeId].push(supporter)     // Add to supporters list
isSupporter[initiativeId][supporter] = true  // Mark as supporter

// Lock tracking
initiativeLocks[initiativeId].push(tokenId)  // Track locks per initiative
supporterLocks[supporter].push(tokenId)      // Track locks per supporter
```

## Redemption

You cannot withdraw tokens early. Redemption is only available when:

1. **Initiative is Accepted**
   - Must wait for `releaseLockDuration` to pass (if configured)
   - Auto-claims incentive rewards on redemption

2. **Initiative is Expired**
   - Immediate redemption available
   - No incentive rewards

3. **Board is Closed**
   - Emergency override - all locks become immediately redeemable
   - Bypasses release timelock

### Redemption Function

```solidity
function redeem(uint256 tokenId) public
```

**See the redemption documentation for detailed information.**

## Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| `Signals_BoardNotYetOpen` | Current time < `boardOpensAt` | Wait for board to open |
| `Signals_BoardClosed` | Board is closed | Cannot support on closed boards |
| `Signals_InitiativeNotFound` | Invalid initiative ID | Use valid initiative ID |
| `Signals_NotProposedState` | Initiative not in Proposed state | Only support Proposed initiatives |
| `Signals_InvalidLockDuration` | Duration = 0 or > `maxLockIntervals` | Use valid duration |
| `Signals_InsufficientTokens` | Balance < amount | Acquire more tokens |
| `Signals_TokenTransferFailed` | Transfer failed | Check approval and balance |
| `Signals_ParticipantInsufficientBalance` | Balance < `minBalance` | Acquire more tokens |
| `Signals_ParticipantInsufficientDuration` | Haven't held tokens long enough | Wait or use different account |
| `Signals_ParticipantNoCheckpointSupport` | Token doesn't support IVotes | Board misconfigured |

## Complete Example Flow

```solidity
// Setup
address supporter = 0x1111
uint256 initiativeId = 5
IERC20 token = IERC20(signals.underlyingToken())

// 1. Check eligibility
require(signals.canParticipate(supporter), "Not eligible")

// 2. Check initiative state
Initiative memory init = signals.getInitiative(initiativeId)
require(init.state == InitiativeState.Proposed, "Not proposed")

// 3. Approve tokens
uint256 amount = 150 * 1e18
token.approve(address(signals), amount)

// 4. Support initiative
uint256 lockDuration = 6  // 6 intervals
uint256 tokenId = signals.supportInitiative(initiativeId, amount, lockDuration)

// 5. Verify NFT received
require(signals.ownerOf(tokenId) == supporter, "NFT not received")

// 6. Check lock details
TokenLock memory lock = signals.getTokenLock(tokenId)
assert(lock.tokenAmount == amount)
assert(lock.lockDuration == lockDuration)

// 7. Check weight contribution
uint256 myWeight = signals.getWeightForSupporterAt(
    initiativeId,
    supporter,
    block.timestamp
)
// Initial: myWeight = 150 * 6 = 900 (decays over time)

// 8. Check total initiative weight
uint256 totalWeight = signals.getWeight(initiativeId)
uint256 threshold = signals.acceptanceThreshold()
bool meetsThreshold = totalWeight >= threshold

// 9. Later: Redeem after acceptance/expiration
// ... wait for acceptance/expiration ...
signals.redeem(tokenId)  // Receive original tokens back + incentives
```

## Integration with Incentives

If the board has incentives enabled:

- **Early supporters get more rewards** - Time-weighted based on when you lock
- **Rewards are calculated on acceptance** - Based on your weight contribution
- **Auto-claimed on redemption** - No need to manually claim
- **Multiple locks are weighted independently** - Each position earns rewards

### Check Potential Rewards

```solidity
// Preview rewards before acceptance (if IncentivesPool configured)
uint256 rewards = incentivesPool.getSupporterRewards(
    address(signals),
    initiativeId,
    supporter
)
```

## Helper Functions

```solidity
// Check if you can participate
function canParticipate(address participant) external view returns (bool)

// Get participant requirements
function getParticipantRequirements() external view returns (ParticipantRequirements memory)

// Get all your lock positions
function getLocksForSupporter(address supporter) external view returns (uint256[] memory)

// Get lock count for supporter
function getLockCountForSupporter(address supporter) external view returns (uint256)

// List all NFT positions you own
function listPositions(address owner) external view returns (uint256[] memory)
```

## Best Practices

### Lock Duration Strategy

- **Longer locks = higher initial weight** but decay to zero
- **Shorter locks = lower initial weight** but less decay risk
- Consider initiative momentum and time to acceptance

### Amount Strategy

- **Larger amounts** contribute more weight toward threshold
- **Multiple smaller locks** provide flexibility for different durations
- Balance between conviction and liquidity needs

### Timing

- **Early support** earns more incentive rewards (if configured)
- **Wait for momentum** if unsure about initiative viability
- Check `lastActivity` timestamp to gauge recent support

### Risk Management

- Only support initiatives you believe will be accepted
- Remember tokens are locked until acceptance or expiration (60+ days default)
- Consider board's `releaseLockDuration` for exit timeline
- NFTs are tradable if you need early liquidity