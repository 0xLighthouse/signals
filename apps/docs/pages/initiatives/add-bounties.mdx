---
title: "Adding Bounties to Initiatives"
weight: 5
---

# Adding Bounties to Initiatives

Bounties allow anyone to contribute external ERC20 token rewards to specific initiatives. When an initiative is accepted, bounties are automatically distributed according to configurable splits between protocol fees, supporter rewards, and treasury.

## Overview

The Bounties system enables:
- External funding of initiatives with whitelisted ERC20 tokens
- Automatic distribution on initiative acceptance
- Configurable three-way splits (protocol/supporters/treasury)
- Multiple bounties per initiative
- Optional expiration timestamps

**Key Difference from Incentives:** Bounties are externally funded and initiative-specific, while Incentives are board-wide and DAO-funded.

## Adding a Bounty

### Function Signature

```solidity
function addBounty(
    uint256 _initiativeId,
    address _token,
    uint256 _amount,
    uint256 _expiresAt,
    Conditions _terms
) external payable
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `_initiativeId` | `uint256` | Initiative ID to attach bounty to |
| `_token` | `address` | ERC20 token address (must be whitelisted) |
| `_amount` | `uint256` | Amount of tokens to contribute |
| `_expiresAt` | `uint256` | Unix timestamp when bounty expires (0 = never) |
| `_terms` | `Conditions` | Distribution conditions (currently only `NONE` implemented) |

### Requirements

1. ✅ **Token must be whitelisted** in TokenRegistry
2. ✅ **Initiative must exist**
3. ✅ **Caller must have sufficient balance**
4. ✅ **Caller must approve Bounties contract**
5. ✅ **Tokens transferred immediately** upon adding

### Example

```solidity
// 1. Approve tokens
IERC20(usdcToken).approve(address(bounties), 10_000e6)

// 2. Add bounty
bounties.addBounty(
    5,                              // initiativeId
    address(usdcToken),             // token
    10_000e6,                       // 10,000 USDC
    block.timestamp + 30 days,      // expires in 30 days
    IBounties.Conditions.NONE       // no special conditions
)
```

## Token Whitelisting

Only whitelisted tokens can be used for bounties.

### TokenRegistry Contract

```solidity
// Add token to whitelist (TOKEN_MANAGER_ROLE only)
function allow(address _token) external onlyRole(TOKEN_MANAGER_ROLE)

// Remove token from whitelist
function deny(address _token) external onlyRole(TOKEN_MANAGER_ROLE)

// Check if token is whitelisted
function isAllowed(address _token) external view returns (bool)
```

**Validation:** Registry checks for ERC20 compliance (`totalSupply`, `decimals`, `balanceOf`).

## Distribution Mechanics

### When Bounties Are Distributed

Automatically when the board owner accepts an initiative:

```solidity
// In Signals.acceptInitiative()
if (address(bounties) != address(0)) {
    bounties.handleInitiativeAccepted(initiativeId)
}
```

### Distribution Formula

```solidity
// For each token type:
protocolAmount = (totalAmount * protocolAllocation) / 100
voterAmount = (totalAmount * voterAllocation) / 100
treasuryAmount = (totalAmount * treasuryAllocation) / 100
```

### Default Split Configuration

```solidity
// Example configuration
uint256[3] memory allocations = [5, 20, 75]
// 5% to protocol fees
// 20% to voter/supporter rewards
// 75% to treasury
```

**Note:** Basis is 100 (not 10,000), so values are direct percentages.

### Supporter Share Calculation

Each supporter's share of the voter pool is proportional to their locked amount:

```solidity
supporterShare = (lockedAmount / totalLocked) * voterAmount
```

## Bounty Data Structure

```solidity
struct Bounty {
    uint256 initiativeId;
    IERC20 token;
    uint256 amount;
    uint256 paid;              // Future use
    uint256 refunded;          // Future use
    uint256 expiresAt;         // 0 = never expires
    address contributor;
    Conditions terms;
}
```

## Querying Bounties

### Get Aggregated Bounties

```solidity
function getBounties(uint256 _initiativeId) external view
    returns (
        address[] memory tokens,
        uint256[] memory amounts,
        uint256 expiredCount
    )
```

Returns aggregated bounties by token type, excluding expired bounties.

### Preview Rewards

```solidity
function previewRewards(uint256 _initiativeId, uint256 _tokenId)
    external view returns (uint256)
```

Estimates rewards for a specific lock position (NFT token).

**⚠️ Known Limitation:** Mixes different token denominations into single number - only an approximation.

## Claiming Bounty Rewards

### Current Status

**⚠️ Important:** Claim/withdrawal functions are **not yet implemented** in the contract.

**Current behavior:**
- ✅ Distribution happens automatically on acceptance
- ✅ Balances tracked in contract: `balances[address][token]`
- ❌ No withdrawal function to claim rewards yet
- ❌ Funds accumulate but cannot be withdrawn

**Expected future implementation:**
```solidity
// Not yet implemented
function claimRewards(address token) external {
    uint256 amount = balances[msg.sender][token]
    require(amount > 0, "No rewards")
    balances[msg.sender][token] = 0
    IERC20(token).safeTransfer(msg.sender, amount)
}
```

## Expiring Bounties

### How Expiration Works

Bounties with `expiresAt > 0` are excluded from distribution if expired:

```solidity
// In getBounties()
if (bounty.expiresAt != 0 && block.timestamp > bounty.expiresAt) {
    _expiredCount++
    continue  // Skip this bounty
}
```

### Refund Mechanism

**⚠️ Not Yet Implemented:** Expired bounties should be refundable to contributors, but this logic is marked as TODO in the code.

## Configuration & Versioning

### Update Distribution Splits

```solidity
function updateSplits(
    uint256[3] memory _allocations,
    address[3] memory _receivers
) external onlyOwner
```

**Requirements:**
- Only owner can call
- Allocations must sum to 100
- Creates new version (doesn't affect existing bounties)

**Example:**
```solidity
bounties.updateSplits(
    [uint256(10), uint256(60), uint256(30)],
    [protocolAddr, votersAddr, treasuryAddr]
)
```

### Why Versioning?

The contract uses versioned configurations to prevent retroactive changes:

```solidity
uint256 public version  // Current version
mapping(uint256 => uint256[3]) public allocations  // Historical
mapping(uint256 => address[3]) public receivers    // Historical
```

## Events Emitted

```solidity
event BountyAdded(
    uint256 indexed bountyId,
    uint256 indexed initiativeId,
    address indexed token,
    uint256 amount,
    uint256 expiresAt,
    Conditions terms
)

event BountiesUpdated(uint256 version)
```

## Validation & Errors

| Error | Condition | Solution |
|-------|-----------|----------|
| `Bounties_TokenNotRegistered` | Token not whitelisted | Add token to TokenRegistry |
| `Bounties_InvalidInitiative` | Initiative doesn't exist | Use valid initiative ID |
| `Bounties_InsufficientBalance` | Not enough tokens | Acquire more tokens |
| `Bounties_InsufficientAllowance` | Not approved | Approve Bounties contract |
| `Bounties_InvalidAllocation` | Allocations don't sum to 100 | Fix split configuration |
| `Bounties_NotAuthorized` | Caller not authorized | Must be Signals contract or owner |

## Integration with Signals

### Setting Bounties Contract

```solidity
// In Signals.sol (owner only)
function setBounties(address _bounties) external onlyOwner
```

### Automatic Calls

**On Acceptance:**
```solidity
bounties.handleInitiativeAccepted(initiativeId)
```

**On Expiration:**
```solidity
bounties.handleInitiativeExpired(initiativeId)  // Refund logic TODO
```

## Complete Example Flow

```solidity
// 1. Deploy Bounties system
TokenRegistry registry = new TokenRegistry()
registry.allow(address(usdcToken))

uint256[3] memory allocations = [5, 20, 75]
address[3] memory receivers = [protocolAddr, votersAddr, treasuryAddr]

Bounties bounties = new Bounties(
    address(signals),
    address(registry),
    allocations,
    receivers
)

signals.setBounties(address(bounties))

// 2. Contributor adds bounty
usdcToken.approve(address(bounties), 10_000e6)
bounties.addBounty(
    initiativeId,
    address(usdcToken),
    10_000e6,
    0,  // Never expires
    IBounties.Conditions.NONE
)

// 3. Initiative gets accepted
signals.acceptInitiative(initiativeId)
// Bounties automatically distributed:
// - Protocol: 500 USDC (5%)
// - Voters: 2,000 USDC (20%)
// - Treasury: 7,500 USDC (75%)

// 4. Supporters would claim (when implemented)
// bounties.claimRewards(address(usdcToken))
```

## Frontend Integration

```typescript
// Check if bounties exist
const { tokens, amounts, expiredCount } = await bounties.read.getBounties([initiativeId])

// Preview potential rewards for a lock position
const estimated = await bounties.read.previewRewards([initiativeId, nftTokenId])

// Check balance (after acceptance)
const balance = await bounties.read.balances([userAddress, tokenAddress])
```

## Best Practices

### For Contributors

1. **Whitelist token first** - Ensure token is in TokenRegistry
2. **Set reasonable expiration** - Give initiative time to gain support
3. **Diversify tokens** - Consider multiple token types for broad appeal
4. **Monitor initiative** - Track progress toward acceptance

### For Board Owners

1. **Configure fair splits** - Balance protocol sustainability and supporter incentives
2. **Whitelist carefully** - Only add trusted, liquid tokens
3. **Update splits thoughtfully** - Use versioning to prevent retroactive changes
4. **Communicate changes** - Inform community of configuration updates

### Security Considerations

1. **Token whitelisting** prevents malicious tokens
2. **Immediate transfer** on `addBounty()` secures funds
3. **Versioned splits** prevent retroactive changes
4. **ReentrancyGuard** protects distribution
5. **SafeERC20** ensures safe token transfers

## Limitations & TODOs

**Current Limitations:**
1. ❌ **No claim/withdrawal function** - Rewards accumulate but can't be claimed
2. ❌ **No refund mechanism** - Expired bounties can't be reclaimed by contributors
3. ⚠️ **Mixed token denominations** - `previewRewards()` mixes different tokens into single estimate
4. ⚠️ **No storage optimization** - Expired bounties remain in storage

**Planned Features** (from code TODOs):
- Implement reward claiming for supporters
- Implement refund logic for expired bounties
- Consider event-driven pattern for Signals integration
- Optimize gas for large bounty lists