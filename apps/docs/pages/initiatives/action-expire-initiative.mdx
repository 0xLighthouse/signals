---
title: "Actioning and Expiring Initiatives"
weight: 4
---

# Actioning and Expiring Initiatives

Board owners have two key functions to manage initiative lifecycle: **accepting** successful proposals and **expiring** inactive ones. Both actions are permanent and trigger different outcomes for supporters.

## Initiative States

```solidity
enum InitiativeState {
    Proposed,    // Initial state when created
    Accepted,    // Owner approved the initiative
    Cancelled,   // DEFINED BUT NEVER USED - no function implements this
    Expired      // Owner expired due to inactivity
}
```

## State Transitions

### Valid Transitions

```
Proposed → Accepted  (via acceptInitiative)
Proposed → Expired   (via expireInitiative)
```

### Invalid Transitions

- ❌ Cannot expire an Accepted initiative
- ❌ Cannot accept an Expired initiative
- ❌ Cannot transition to Cancelled state (no function exists)
- ❌ Cannot reverse Accepted or Expired back to Proposed

**All state transitions are ONE-WAY and PERMANENT.**

---

# Accepting an Initiative

Accepting an initiative means the board owner officially approves it, transitioning it from Proposed to Accepted state. This triggers bounty distribution, incentive calculation, and makes locked tokens redeemable.

## Function Signature

```solidity
function acceptInitiative(uint256 initiativeId) external payable onlyOwner
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `initiativeId` | `uint256` | ID of the initiative to accept |

### Access Control

**Owner-only function** - Only the board owner can accept initiatives.

## Pre-conditions

1. ✅ **Initiative must exist** - `initiativeId <= initiativeCount`
2. ✅ **Initiative must be in Proposed state** - Cannot accept already Accepted or Expired initiatives
3. ✅ **Caller must be owner** - Access restricted via `onlyOwner` modifier

### Important: No Automatic Threshold Check

The function **does not enforce** that the initiative has reached `acceptanceThreshold`. The owner has full discretion to accept initiatives regardless of weight.

**Check threshold manually:**
```solidity
uint256 currentWeight = signals.getWeight(initiativeId)
uint256 threshold = signals.acceptanceThreshold()
bool meetsThreshold = currentWeight >= threshold
```

## What Happens When Accepting

When an initiative is accepted:

1. **State changes** to `Accepted` (irreversible)
2. **Acceptance timestamp** is recorded (`acceptanceTimestamp = block.timestamp`)
3. **Bounties are automatically distributed** (if configured)
4. **Incentive rewards are calculated** (if configured)
5. **Supporters can redeem** their locked tokens (after release timelock)

### Automatic Integrations

#### Bounties Distribution

If bounties are configured, they're automatically distributed:

```solidity
if (address(bounties) != address(0)) {
    bounties.handleInitiativeAccepted(initiativeId)
}
```

**Distribution splits** (configurable):
- Protocol fee (e.g., 5%)
- Supporter rewards (e.g., 20%)
- Treasury (e.g., 75%)

Supporters must claim their bounty rewards separately from the Bounties contract.

#### Incentives Calculation

If an incentives pool is configured, rewards are calculated:

```solidity
if (address(incentivesPool) != address(0)) {
    incentivesPool.calculateIncentives(
        initiativeId,
        boardOpensAt,
        block.timestamp
    )
}
```

**Time-weighted rewards:**
- Early supporters get more rewards
- Based on linear decay from board open time
- Automatically claimed when supporters redeem locks

## Impact on Token Locks (Accepted)

### Redemption Timeline

Locked tokens become redeemable based on `releaseLockDuration`:

**Immediate Release (`releaseLockDuration = 0`):**
```solidity
// Supporters can redeem immediately
signals.redeem(tokenId)
```

**Timelocked Release (`releaseLockDuration > 0`):**
```solidity
// Must wait for timelock
uint256 releaseTime = initiative.acceptanceTimestamp + releaseLockDuration

// Example: 7 days
if (block.timestamp < releaseTime) {
    revert Signals_StillTimelocked() // Cannot redeem yet
}
```

**Emergency Override:**
If the board is closed via `closeBoard()`, the release timelock is bypassed and all locks become immediately redeemable.

## Events Emitted (Accept)

```solidity
event InitiativeAccepted(uint256 indexed initiativeId, address indexed actor)
```

## Validation & Errors (Accept)

| Error | Condition | Solution |
|-------|-----------|----------|
| `Signals_InitiativeNotFound` | Invalid initiative ID | Use valid ID (1 to initiativeCount) |
| `Signals_NotProposedState` | Initiative not in Proposed state | Only accept Proposed initiatives |
| `OwnableUnauthorizedAccount` | Caller is not owner | Must be board owner |

## Example: Accepting an Initiative

```solidity
// 1. Check initiative exists and is proposed
Initiative memory init = signals.getInitiative(initiativeId)
require(init.state == InitiativeState.Proposed, "Not proposed")

// 2. Verify weight meets threshold (optional - owner discretion)
uint256 weight = signals.getWeight(initiativeId)
uint256 threshold = signals.acceptanceThreshold()
require(weight >= threshold, "Below threshold")

// 3. Accept initiative (owner only)
signals.acceptInitiative(initiativeId)

// 4. Verify state change
Initiative memory accepted = signals.getInitiative(initiativeId)
assert(accepted.state == InitiativeState.Accepted)
assert(accepted.acceptanceTimestamp == block.timestamp)
```

---

# Expiring an Initiative

Expiring an initiative terminates an inactive proposal that has failed to gain sufficient support. This frees supporters to redeem their locked tokens immediately.

## Function Signature

```solidity
function expireInitiative(uint256 initiativeId) external payable onlyOwner
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `initiativeId` | `uint256` | ID of the initiative to expire |

### Access Control

**Owner-only** - Uses `onlyOwner` modifier.

## Pre-conditions

1. ✅ **Initiative must exist**
2. ✅ **Initiative must be in Proposed state** - Cannot expire Accepted initiatives
3. ✅ **Initiative must be inactive** for ≥ `activityTimeout` (default 60 days)

**Activity tracking:**
- `lastActivity` updates when:
  - Initiative is created
  - Any supporter locks tokens
- Default timeout: 60 days (configurable via `setInactivityThreshold`)

### Validation

```solidity
// Must be in Proposed state
if (initiative.state != InitiativeState.Proposed) {
    revert Signals_NotProposedState()
}

// Must be inactive long enough
if (block.timestamp <= initiative.lastActivity + activityTimeout) {
    revert Signals_NotEligibleForExpiration()
}
```

## What Happens When Expiring

1. **State changes** to `Expired`
2. **Notifies Bounties contract** (if configured): `bounties.handleInitiativeExpired(initiativeId)`
3. **Emits** `InitiativeExpired` event

**Note:** Bounty refund logic is not yet implemented (marked as TODO in code).

## Impact on Token Locks (Expired)

### Redemption from Expired Initiatives

Supporters can redeem **immediately** - no timelock:

```solidity
// No timelock for expired initiatives
signals.redeem(tokenId)
```

**Redemption requirements:**
```solidity
// Must be Accepted OR Expired
if (!(initiative.state == InitiativeState.Accepted ||
      initiative.state == InitiativeState.Expired)) {
    revert Signals_NotWithdrawableState()
}
```

## Events Emitted (Expire)

```solidity
event InitiativeExpired(uint256 indexed initiativeId, address indexed actor)
```

## Validation & Errors (Expire)

| Error | Condition | Solution |
|-------|-----------|----------|
| `Signals_InitiativeNotFound` | Invalid initiative ID | Use valid ID |
| `Signals_NotProposedState` | Initiative not in Proposed state | Can only expire Proposed initiatives |
| `Signals_NotEligibleForExpiration` | Not inactive long enough | Wait for `activityTimeout` to pass |
| `OwnableUnauthorizedAccount` | Caller is not owner | Must be board owner |

## Configuration: Inactivity Threshold

```solidity
function setInactivityThreshold(uint256 _newThreshold) external onlyOwner
```

**Default:** 60 days (5,184,000 seconds)

**Example:**
```solidity
// Set to 30 days
signals.setInactivityThreshold(30 days)
```

## Example: Expiring an Initiative

```solidity
// 1. Check if eligible for expiration
Initiative memory init = signals.getInitiative(initiativeId)
require(init.state == InitiativeState.Proposed, "Not proposed")

uint256 timeSinceActivity = block.timestamp - init.lastActivity
uint256 timeout = signals.activityTimeout()
require(timeSinceActivity >= timeout, "Not inactive long enough")

// 2. Expire initiative (owner only)
signals.expireInitiative(initiativeId)

// 3. Verify state change
Initiative memory expired = signals.getInitiative(initiativeId)
assert(expired.state == InitiativeState.Expired)

// 4. Supporters can now redeem immediately
signals.redeem(tokenId)  // No timelock
```

---

# State Comparison

| Aspect | Proposed | Accepted | Expired |
|--------|----------|----------|---------|
| **Can receive new locks** | ✅ Yes | ❌ No | ❌ No |
| **Can be redeemed** | ❌ No | ✅ Yes (after timelock) | ✅ Yes (immediately) |
| **Gets incentive rewards** | ❌ No | ✅ Yes | ❌ No |
| **Bounty handling** | None | Distributed | Refund (TODO) |
| **Can be accepted** | ✅ Yes | N/A | ❌ No |
| **Can be expired** | ✅ Yes (after timeout) | ❌ No | N/A |
| **Release timelock** | N/A | Applies | **Bypassed** |

## What Supporters Get

**From Accepted initiatives:**
- ✅ Original locked tokens returned
- ✅ Incentive rewards (auto-claimed on redemption)
- ✅ Bounty rewards (claim separately from Bounties contract)
- ⏰ Must wait for `releaseLockDuration`

**From Expired initiatives:**
- ✅ Original locked tokens returned (immediately)
- ❌ No incentive rewards
- ⚠️ Bounty refunds not yet implemented

---

# What Happens After

## For Supporters (After Acceptance)

1. **Wait for release timelock** (if configured)
   ```solidity
   uint256 releaseTime = initiative.acceptanceTimestamp + releaseLockDuration
   ```

2. **Redeem lock positions**
   ```solidity
   signals.redeem(tokenId)
   ```
   - Burns NFT
   - Returns underlying tokens
   - Auto-claims incentive rewards

3. **Claim bounty rewards** (if applicable)
   ```solidity
   bounties.withdraw(tokenAddress)
   ```

## For Supporters (After Expiration)

1. **Redeem immediately** - no waiting period
   ```solidity
   signals.redeem(tokenId)
   ```
   - Burns NFT
   - Returns underlying tokens
   - No incentive rewards

## For Multiple Locks

If a supporter has multiple locks on the same initiative:
- Each lock must be redeemed individually
- Incentive rewards (Accepted only) are calculated across all locks
- First redemption claims all incentive rewards (idempotent)

---

# When to Use Each Action

## Use `acceptInitiative()` when:

1. ✅ Initiative has reached or exceeded acceptance threshold
2. ✅ Initiative is well-formed and actionable
3. ✅ Community consensus supports the proposal
4. ✅ You're ready to implement the proposal
5. ✅ Bounties and incentives are correctly configured

## Use `expireInitiative()` when:

1. ✅ Initiative has been inactive (no new locks) for 60+ days
2. ✅ Initiative will clearly never gain enough support
3. ✅ You want to free supporters to redeem their locked tokens
4. ✅ You want to clean up stale proposals

**Don't use expiration for:**
- ❌ Accepted initiatives (cannot expire)
- ❌ Recently active proposals
- ❌ Proposals you disagree with (let community decide)

---

# Best Practices

## Before Accepting

1. **Verify weight** - Check if threshold is met (though not required)
2. **Review proposal** - Ensure initiative is valid and actionable
3. **Check bounties** - Verify bounty configuration is correct
4. **Communicate intent** - Inform community of acceptance
5. **Consider timing** - Accept when community expectations align

## Before Expiring

1. **Wait for full timeout** - Don't expire prematurely
2. **Communicate with community** - Explain why expiring
3. **Check for recent activity** - Ensure no ongoing momentum
4. **Consider alternatives** - Could it be saved with more time?

## After Either Action

1. **Notify supporters** - Inform them about redemption options
2. **Track redemptions** - Monitor supporter activity
3. **Update records** - Document decision for governance tracking
4. **Implement (if accepted)** - Follow through on accepted proposals

---

# Integration Examples

## Check and Accept Initiative

```typescript
// Owner dashboard - check if initiative should be accepted
async function shouldAccept(initiativeId: bigint) {
  const initiative = await signals.read.getInitiative([initiativeId])

  // Must be proposed
  if (initiative.state !== 0) return false  // 0 = Proposed

  // Check weight vs threshold
  const weight = await signals.read.getWeight([initiativeId])
  const threshold = await signals.read.acceptanceThreshold()

  // Owner's discretion
  return weight >= threshold
}

// Accept initiative
async function accept(initiativeId: bigint) {
  const tx = await signals.write.acceptInitiative([initiativeId])
  await tx.wait()

  console.log(`Initiative ${initiativeId} accepted`)
  notifySupporters(initiativeId)
}
```

## Check and Expire Inactive Initiative

```typescript
// Check if initiative can be expired
async function canExpire(initiativeId: bigint) {
  const initiative = await signals.read.getInitiative([initiativeId])

  // Must be proposed
  if (initiative.state !== 0) return false

  // Check inactivity
  const timeout = await signals.read.activityTimeout()
  const timeSinceActivity = BigInt(Date.now() / 1000) - initiative.lastActivity

  return timeSinceActivity >= timeout
}

// Expire initiative
async function expireInactive(initiativeId: bigint) {
  if (!(await canExpire(initiativeId))) {
    throw new Error("Not eligible for expiration")
  }

  const tx = await signals.write.expireInitiative([initiativeId])
  await tx.wait()

  console.log(`Initiative ${initiativeId} expired`)
}
```

## Check Redemption Status

```solidity
// Check if initiative is redeemable
Initiative memory init = signals.getInitiative(initiativeId)
bool isRedeemable = (init.state == InitiativeState.Accepted ||
                     init.state == InitiativeState.Expired)

// For Accepted: check if timelock has passed
if (init.state == InitiativeState.Accepted) {
    uint256 releaseTime = init.acceptanceTimestamp + releaseLockDuration
    bool canRedeemNow = block.timestamp >= releaseTime
}

// For Expired: can redeem immediately
if (init.state == InitiativeState.Expired) {
    bool canRedeemNow = true  // No timelock
}

// Check incentive rewards (Accepted only)
if (init.state == InitiativeState.Accepted && address(incentivesPool) != address(0)) {
    uint256 rewards = incentivesPool.getSupporterRewards(
        address(signals),
        initiativeId,
        supporter
    )
}
```

---

# Related Functions

```solidity
// Query functions
function getInitiative(uint256 initiativeId) external view returns (Initiative memory)
function getWeight(uint256 initiativeId) external view returns (uint256)
function acceptanceThreshold() external view returns (uint256)
function releaseLockDuration() external view returns (uint256)
function activityTimeout() external view returns (uint256)

// Owner functions for managing initiatives
function acceptInitiative(uint256 initiativeId) external onlyOwner
function expireInitiative(uint256 initiativeId) external onlyOwner
function setInactivityThreshold(uint256 _threshold) external onlyOwner

// Emergency action
function closeBoard() external onlyOwner  // Bypasses all timelocks
```