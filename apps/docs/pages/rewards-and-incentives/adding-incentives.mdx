---
title: "Adding Incentives to a Board"
weight: 2
---

# Adding Incentives to a Board

Incentives are board-wide reward pools that incentivize early support across all initiatives. They use time-weighted distribution to reward supporters who identify and back promising proposals early.

## Overview

The incentives system:
- ✅ Rewards early supporters with more tokens
- ✅ Funded by DAO/board owner upfront
- ✅ Distributed across all accepted initiatives
- ✅ Auto-claimed when supporters redeem locks
- ✅ Non-blocking (doesn't prevent acceptance if depleted)

## Prerequisites

Before adding incentives:

1. ✅ **Deploy your Signals board** via SignalsFactory
2. ✅ **Have reward tokens** ready (typically DAO governance token)
3. ✅ **Configure board with incentives enabled** during deployment
4. ✅ **Set up BEFORE board opens** - cannot add after `boardOpensAt`

## Step-by-Step Setup

### Step 1: Enable Incentives During Board Creation

When deploying your board, configure the `BoardIncentives` struct:

```solidity
// Configure incentives
BoardIncentives memory incentives = BoardIncentives({
    enabled: true,              // Enable incentives
    curveType: 0,              // 0 = linear decay
    curveParameters: [0.12e18] // 12% decay rate
})

// Include in board deployment
ISignalsFactory.FactoryDeployment memory config = ISignalsFactory.FactoryDeployment({
    owner: daoMultisig,
    underlyingToken: governanceToken,
    acceptanceThreshold: 500_000 * 1e18,
    // ... other parameters ...
    boardIncentives: incentives  // Enable here
})

// Deploy board
address boardAddress = factory.create(config)
```

**Important:** If `enabled: false`, you cannot add incentives later.

### Step 2: Deploy IncentivesPool Contract

```solidity
// Deploy new IncentivesPool
IncentivesPool pool = new IncentivesPool()
```

The IncentivesPool contract manages:
- Reward token storage
- Distribution calculations
- Board approvals
- Reward claiming

### Step 3: Initialize the Pool with Funds

```solidity
// Approve reward tokens
IERC20 rewardToken = IERC20(daoTokenAddress)
rewardToken.approve(address(pool), totalRewards)

// Initialize pool
pool.initializePool(
    address(rewardToken),    // DAO token address
    1_000_000 * 1e18,       // Total pool: 1M tokens
    10_000 * 1e18           // Max per initiative: 10k tokens
)
```

#### Parameters Explained

**`rewardToken`**
- ERC20 token used for rewards
- Typically your DAO's governance token
- Must approve pool to spend tokens

**`totalPoolAmount`**
- Total tokens available for rewards
- Transferred immediately to pool
- Shared across all accepted initiatives on the board

**`maxRewardPerInitiative`**
- Maximum tokens allocated per initiative
- Prevents single initiative from depleting pool
- Example: 1M total / 10k max = up to 100 initiatives

### Step 4: Approve the Board

The pool must explicitly approve which boards can use it:

```solidity
// Approve your Signals board
pool.approveBoard(address(signalsBoard))
```

**Security feature:** Prevents unauthorized boards from accessing the pool.

### Step 5: Link Pool to Board

Finally, connect the pool to your board:

```solidity
// Must be called BEFORE boardOpensAt
signalsBoard.setIncentivesPool(address(pool))
```

**Critical timing:** This must be called before `boardOpensAt` timestamp. Once the board opens, you cannot change the incentives pool.

## Complete Deployment Example

```solidity
// 1. Deploy board with incentives enabled
BoardIncentives memory incentives = BoardIncentives({
    enabled: true,
    curveType: 0,
    curveParameters: [uint256(0.12e18)]
})

ISignalsFactory.FactoryDeployment memory config = ISignalsFactory.FactoryDeployment({
    owner: daoMultisig,
    underlyingToken: governanceToken,
    acceptanceThreshold: 500_000 * 1e18,
    maxLockIntervals: 365,
    proposalCap: 20,
    lockInterval: 1 days,
    decayCurveType: 0,
    decayCurveParameters: [uint256(9e17)],
    proposerRequirements: ProposerRequirements({
        eligibilityType: EligibilityType.None,
        minBalance: 0,
        minHoldingDuration: 0,
        threshold: 50_000 * 1e18
    }),
    participantRequirements: ParticipantRequirements({
        eligibilityType: EligibilityType.None,
        minBalance: 0,
        minHoldingDuration: 0
    }),
    releaseLockDuration: 0,
    boardOpensAt: block.timestamp + 1 days,  // Opens in 1 day
    boardIncentives: incentives
})

address boardAddress = factory.create(config)
Signals signalsBoard = Signals(boardAddress)

// 2. Deploy IncentivesPool
IncentivesPool pool = new IncentivesPool()

// 3. Initialize pool with 1M tokens
IERC20 daoToken = IERC20(daoTokenAddress)
daoToken.approve(address(pool), 1_000_000 * 1e18)

pool.initializePool(
    address(daoToken),
    1_000_000 * 1e18,    // 1M total
    10_000 * 1e18        // 10k max per initiative
)

// 4. Approve board
pool.approveBoard(address(signalsBoard))

// 5. Link to board (before it opens!)
signalsBoard.setIncentivesPool(address(pool))

// Board opens in 1 day, incentives are ready!
```

## Incentive Configuration

### Decay Curve Types

The `curveType` determines how early supporter bonuses are calculated:

#### Linear Decay (Type 0)

```solidity
curveType: 0
curveParameters: [k]  // e.g., [0.12e18] = 12% decay rate
```

**Formula:**
```
weight = lockAmount * (1 - k * t)

where t = (lockTime - boardOpensAt) / (acceptanceTime - boardOpensAt)
```

**Example with k=0.12:**
- Lock at board open (t=0): weight = 100 * (1 - 0.12 * 0) = 100.0
- Lock at midpoint (t=0.5): weight = 100 * (1 - 0.12 * 0.5) = 94.0
- Lock at acceptance (t=1): weight = 100 * (1 - 0.12 * 1) = 88.0

**Use when:** You want gradual, predictable early supporter bonuses.

#### Future: Exponential Decay (Type 1)

Currently only linear decay is implemented. Exponential decay would provide:
- Steeper early bonus
- Rapidly diminishing returns for late supporters

### Choosing Decay Rate

The decay parameter `k` controls how much early supporters are rewarded:

| Decay Rate | Early Bonus | Use Case |
|------------|-------------|----------|
| `0.05e18` (5%) | Low | Reward all supporters fairly equally |
| `0.12e18` (12%) | Medium | Standard early supporter advantage |
| `0.20e18` (20%) | High | Strong incentive to evaluate early |
| `0.30e18` (30%) | Very High | Maximum urgency for early support |

**Recommendation:** Start with 0.12 (12%) for balanced incentives.

### Pool Sizing Guidelines

**Total Pool Amount:**
```
Conservative: 1-2% of circulating supply
Moderate: 2-5% of circulating supply
Aggressive: 5-10% of circulating supply
```

**Max Per Initiative:**
```
Typical: totalPool / (expected initiatives * 2)
Example: 1M total / (50 expected * 2) = 10k per initiative
```

This allows ~50 initiatives with buffer for multiple acceptances.

## How Incentives Are Distributed

### Automatic Calculation on Acceptance

When the board owner accepts an initiative:

```solidity
// Called automatically in acceptInitiative()
if (address(incentivesPool) != address(0)) {
    try incentivesPool.calculateIncentives(
        initiativeId,
        boardOpensAt,
        block.timestamp
    ) {} catch {
        // Non-blocking: continues even if calculation fails
    }
}
```

The pool:
1. Fetches all supporters and their locks
2. Calculates time-weighted weight for each
3. Allocates rewards proportionally
4. Caps at `maxRewardPerInitiative`
5. Stores individual allocations

### Time-Weighted Calculation

For each supporter's lock:

```solidity
// Calculate time factor
timeFactor = (lockCreatedAt - boardOpensAt) / (acceptanceTime - boardOpensAt)

// Apply decay curve
weight = lockAmount * (1 - decayRate * timeFactor)

// Sum across all locks for supporter
totalWeight = sum of all lock weights

// Calculate reward share
supporterReward = (supporterWeight / totalWeightAllSupporters) * poolAllocation
```

### Automatic Claiming

Rewards are automatically claimed when supporters redeem:

```solidity
// Supporter redeems lock
signals.redeem(tokenId)

// Inside redeem():
if (address(incentivesPool) != address(0) &&
    initiative.state == InitiativeState.Accepted) {
    uint256 rewards = incentivesPool.getSupporterRewards(
        address(this),
        lock.initiativeId,
        msg.sender
    )

    if (rewards > 0) {
        incentivesPool.claimRewards(
            address(this),
            lock.initiativeId,
            msg.sender
        )
        // Tokens transferred to supporter
    }
}
```

**Benefits:**
- No separate claim transaction needed
- Gas efficient
- Automatic for all supporters
- Idempotent (multiple redeems safe)

## Pool Depletion Handling

### Non-Blocking Design

If the pool runs out of funds:

```solidity
// Acceptance still succeeds
try incentivesPool.calculateIncentives(...) {} catch {
    // Silently continues
}
```

**Initiative acceptance is NOT blocked** by pool depletion.

### Monitoring Pool Balance

```solidity
// Check remaining pool balance
uint256 remaining = rewardToken.balanceOf(address(pool))

// Check pool statistics
(address token, uint256 total, uint256 maxPerInit) = pool.poolInfo()

// Check if board is approved
bool approved = pool.approvedBoards(address(signalsBoard))
```

### Refilling Strategy

If pool runs low:

**Option 1: Accept It**
- Let pool deplete naturally
- Later initiatives get fewer/no rewards
- Maintains fair distribution to early participants

**Option 2: Deploy New Board**
- Create new board with fresh pool
- "Season 2" with new budget
- Clean slate for participants

**Cannot:** Add more funds to existing pool mid-season

## Validation & Errors

| Error | Condition | Solution |
|-------|-----------|----------|
| `IncentivesPool_PoolAlreadyInitialized` | Pool already initialized | Deploy new pool |
| `IncentivesPool_BoardNotApproved` | Board not approved | Call `approveBoard()` |
| `IncentivesPool_InsufficientBalance` | Not enough tokens approved | Approve more tokens |
| `Signals_BoardAlreadyOpened` | Trying to set pool after opening | Must set before `boardOpensAt` |
| `Signals_IncentivesNotEnabled` | Board created without incentives | Cannot add to existing board |

## Best Practices

### Sizing the Pool

1. **Estimate initiative volume**
   - Conservative: 20-50 initiatives
   - Moderate: 50-100 initiatives
   - Aggressive: 100+ initiatives

2. **Set appropriate max per initiative**
   ```
   maxPerInitiative = totalPool / (estimatedInitiatives * safetyFactor)
   safetyFactor = 2-3x for buffer
   ```

3. **Consider token value**
   - High value token: smaller pool
   - Low value token: larger pool
   - Target meaningful rewards per initiative

### Decay Rate Selection

**Conservative (5-8%):**
- Small difference between early/late
- Focus on participation over timing
- Good for mature communities

**Standard (10-15%):**
- Noticeable early advantage
- Balanced incentive structure
- Recommended starting point

**Aggressive (20-30%):**
- Strong early mover advantage
- Creates urgency to evaluate
- Good for new boards needing momentum

### Testing Strategy

```solidity
// Test deployment on testnet
1. Deploy with small pool (1,000 tokens)
2. Test full lifecycle:
   - Create initiatives
   - Add support at different times
   - Accept initiatives
   - Redeem and verify rewards
3. Verify calculations match expectations
4. Test pool depletion scenarios
```

### Communication

**Before Launch:**
- Announce total pool size
- Explain decay mechanics
- Set expectations for rewards
- Provide examples of early vs. late

**During Season:**
- Show remaining pool balance
- Highlight incentive opportunities
- Display time factor for pending initiatives
- Show projected rewards

**After Acceptance:**
- Announce rewards distributed
- Show individual allocations
- Remind about auto-claiming

## Querying Pool Information

### Check Pool Status

```solidity
// Get pool configuration
(address token, uint256 total, uint256 maxPerInit) = pool.poolInfo()

// Check remaining balance
uint256 remaining = IERC20(token).balanceOf(address(pool))

// Calculate available initiatives
uint256 remainingInitiatives = remaining / maxPerInit
```

### Check Board Approval

```solidity
// Verify board is approved
bool isApproved = pool.approvedBoards(address(signalsBoard))
```

### Check Supporter Rewards

```solidity
// Preview rewards before claiming
uint256 rewards = pool.getSupporterRewards(
    address(signalsBoard),
    initiativeId,
    supporterAddress
)

// Check if already claimed
uint256 claimed = pool.claimedRewards(
    address(signalsBoard),
    initiativeId,
    supporterAddress
)
```

### Check Initiative Allocation

```solidity
// Get total rewards allocated to initiative
uint256 allocated = pool.getInitiativeRewardPool(
    address(signalsBoard),
    initiativeId
)

// Get total weight used for distribution
uint256 totalWeight = pool.getInitiativeTotalWeight(
    address(signalsBoard),
    initiativeId
)

// Check if distribution calculated
bool calculated = pool.isDistributionCalculated(
    address(signalsBoard),
    initiativeId
)
```

## Frontend Integration Example

```typescript
// Check if board has incentives
const poolAddress = await signalsBoard.read.incentivesPool()
const hasIncentives = poolAddress !== '0x0000000000000000000000000000000000000000'

if (hasIncentives) {
  // Get pool info
  const [token, total, maxPerInit] = await pool.read.poolInfo()
  const remaining = await rewardToken.read.balanceOf([poolAddress])

  // Show incentive info to users
  console.log(`Reward Token: ${token}`)
  console.log(`Total Pool: ${formatEther(total)}`)
  console.log(`Max Per Initiative: ${formatEther(maxPerInit)}`)
  console.log(`Remaining: ${formatEther(remaining)}`)

  // For each initiative, show projected rewards
  const supporters = await signalsBoard.read.getSupporters([initiativeId])

  for (const supporter of supporters) {
    const rewards = await pool.read.getSupporterRewards([
      signalsBoard.address,
      initiativeId,
      supporter
    ])

    console.log(`${supporter}: ${formatEther(rewards)} rewards`)
  }
}
```

## Advanced: Multiple Boards, One Pool

A single IncentivesPool can serve multiple boards:

```solidity
// Deploy one pool
IncentivesPool sharedPool = new IncentivesPool()
sharedPool.initializePool(token, 10_000_000e18, 10_000e18)

// Approve multiple boards
sharedPool.approveBoard(address(board1))
sharedPool.approveBoard(address(board2))
sharedPool.approveBoard(address(board3))

// Each board uses same pool
board1.setIncentivesPool(address(sharedPool))
board2.setIncentivesPool(address(sharedPool))
board3.setIncentivesPool(address(sharedPool))
```

**Use case:** Multi-season governance with shared budget.

## Summary Checklist

Before launching your board with incentives:

- [ ] Board deployed with `boardIncentives.enabled = true`
- [ ] IncentivesPool contract deployed
- [ ] Reward tokens approved and pool initialized
- [ ] Board approved in pool via `approveBoard()`
- [ ] Pool linked to board via `setIncentivesPool()`
- [ ] **All done BEFORE `boardOpensAt` timestamp**
- [ ] Pool sizing appropriate for expected volume
- [ ] Decay rate configured for desired incentive structure
- [ ] Frontend shows pool info and projected rewards
- [ ] Community informed about incentive mechanics

Once complete, your board will:
- ✅ Automatically calculate time-weighted rewards on acceptance
- ✅ Auto-claim rewards when supporters redeem
- ✅ Incentivize early evaluation and support
- ✅ Drive momentum for quality initiatives